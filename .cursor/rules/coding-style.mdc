---
description: coding-style
globs:
alwaysApply: false
---
# Rune Caster - ì½”ë”© ìŠ¤íƒ€ì¼ ê°€ì´ë“œ

## ğŸ¯ í•µì‹¬ ì„¤ê³„ ì›ì¹™

Rune CasterëŠ” **STL ìŠ¤íƒ€ì¼ API**ë¥¼ ë”°ë¦…ë‹ˆë‹¤:
- ì§ê´€ì ì´ê³  ìµìˆ™í•œ ì¸í„°í˜ì´ìŠ¤
- Zero-cost abstractions
- C++20 Modern Features ì ê·¹ í™œìš©

## ğŸ“ ë„¤ì´ë° ê·œì¹™

### í´ë˜ìŠ¤ ë° íƒ€ì… (PascalCase)
```cpp
class Rune;
class RuneSequence;
enum class LanguageCode;
template<typename T> concept RuneLike;
```

### í•¨ìˆ˜ ë° ë³€ìˆ˜ (snake_case)
```cpp
void process_text(const RuneView& input);
auto language_code = detect_language(text);
bool is_valid_input = validate(data);
```

### ë©¤ë²„ ë³€ìˆ˜ (trailing underscore)
```cpp
class Rune {
private:
    char32_t codepoint_;
    language::Code language_;
    std::string phoneme_;
};
```

### ìƒìˆ˜ (SCREAMING_SNAKE_CASE)
```cpp
constexpr std::size_t MAX_PHONEME_LENGTH = 32;
constexpr char32_t INVALID_CODEPOINT = 0xFFFFFFFF;
```

## ğŸ—ï¸ STL ìŠ¤íƒ€ì¼ íŒ¨í„´

### ì»¨í…Œì´ë„ˆ ì¸í„°í˜ì´ìŠ¤
[rune_sequence.hpp](mdc:include/rune_caster/rune_sequence.hpp)ë¥¼ ì°¸ì¡°:

```cpp
class RuneSequence {
public:
    // STL íƒ€ì… ì •ì˜
    using value_type = Rune;
    using iterator = std::vector<Rune>::iterator;
    using const_iterator = std::vector<Rune>::const_iterator;

    // STL ë©”ì„œë“œë“¤
    iterator begin() noexcept;
    iterator end() noexcept;
    size_type size() const noexcept;
    bool empty() const noexcept;

    // ì›ì†Œ ì ‘ê·¼
    reference operator[](size_type pos) noexcept;
    reference at(size_type pos);
};
```

### C++20 Concepts ì‚¬ìš©
[concepts.hpp](mdc:include/rune_caster/concepts.hpp)ë¥¼ ì°¸ì¡°:

```cpp
template<typename T>
concept RuneLike = requires(T t) {
    { t.codepoint() } -> std::convertible_to<char32_t>;
    { t.language() } -> std::convertible_to<language::Code>;
};

template<typename T>
concept RuneContainer = requires(T t) {
    typename T::value_type;
    requires RuneLike<typename T::value_type>;
    { t.begin() } -> std::input_iterator;
    { t.end() } -> std::input_iterator;
};
```

## ğŸ›¡ï¸ íƒ€ì… ì•ˆì „ì„±

### noexcept ì§€ì •
```cpp
// ì˜ˆì™¸ë¥¼ ë˜ì§€ì§€ ì•ŠëŠ” í•¨ìˆ˜ë“¤
constexpr char32_t codepoint() const noexcept;
constexpr bool is_valid() const noexcept;
language::Code detect_language(char32_t cp) noexcept;
```

### [[nodiscard]] ì†ì„±
```cpp
// ë°˜í™˜ê°’ì„ ë¬´ì‹œí•˜ë©´ ì•ˆ ë˜ëŠ” í•¨ìˆ˜ë“¤
[[nodiscard]] bool empty() const noexcept;
[[nodiscard]] std::string to_utf8() const;
[[nodiscard]] static RuneSequence from_utf8(std::string_view utf8_text);
```

### constexpr ì‚¬ìš©
```cpp
// ì»´íŒŒì¼ íƒ€ì„ ê³„ì‚° ê°€ëŠ¥í•œ í•¨ìˆ˜ë“¤
constexpr bool is_hangul(char32_t cp) noexcept;
constexpr bool is_latin(char32_t cp) noexcept;
constexpr unicode::Category get_category(char32_t cp) noexcept;
```

## ğŸ”§ êµ¬í˜„ íŒ¨í„´

### RAII ë° Rule of 5
[rune.hpp](mdc:include/rune_caster/rune.hpp)ë¥¼ ì°¸ì¡°:

```cpp
class Rune {
public:
    // Rule of 5 - ê¸°ë³¸ êµ¬í˜„ ì‚¬ìš©
    Rune(const Rune&) = default;
    Rune(Rune&&) noexcept = default;
    Rune& operator=(const Rune&) = default;
    Rune& operator=(Rune&&) noexcept = default;
    ~Rune() = default;
};
```

### ì•ˆì „í•œ íƒ€ì… ë³€í™˜
```cpp
// ëª…ì‹œì  ë³€í™˜
explicit Rune(char32_t codepoint) noexcept;

// íŒ©í† ë¦¬ ë©”ì„œë“œ
static Rune from_utf8(std::string_view utf8_char);
static RuneSequence from_utf8(std::string_view utf8_text);
```

### ì˜¤ë¥˜ ì²˜ë¦¬
```cpp
// ë²”ìœ„ ê²€ì‚¬
reference at(size_type pos);  // throws std::out_of_range

// ì•ˆì „í•œ ì ‘ê·¼
reference operator[](size_type pos) noexcept;  // no bounds check

// ì˜ˆì™¸ ì „íŒŒ
static Rune from_utf8(std::string_view utf8_char);  // throws on invalid UTF-8
```

## ğŸ“š ë¬¸ì„œí™” ìŠ¤íƒ€ì¼

### Doxygen ì£¼ì„ íŒ¨í„´
```cpp
/**
 * @brief Unicode ë¬¸ìë¥¼ í‘œí˜„í•˜ëŠ” ê¸°ë³¸ í´ë˜ìŠ¤
 *
 * @param codepoint ìœ íš¨í•œ Unicode ì½”ë“œí¬ì¸íŠ¸
 * @return ìƒì„±ëœ Rune ê°ì²´
 * @throws std::invalid_argument ì˜ëª»ëœ ì½”ë“œí¬ì¸íŠ¸
 *
 * @example
 * @code
 * auto rune = Rune{U'ê°€'};
 * std::cout << rune.to_utf8() << std::endl;
 * @endcode
 */
```

## ğŸ¨ ì½”ë“œ í¬ë§·íŒ…

### í—¤ë” í¬í•¨ ìˆœì„œ
```cpp
// 1. í•´ë‹¹ í´ë˜ìŠ¤ì˜ í—¤ë”
#include "rune_caster/rune.hpp"

// 2. í”„ë¡œì íŠ¸ í—¤ë”ë“¤
#include "rune_caster/unicode.hpp"
#include "rune_caster/language.hpp"

// 3. í‘œì¤€ ë¼ì´ë¸ŒëŸ¬ë¦¬
#include <string>
#include <vector>
#include <iostream>
```

### ë„¤ì„ìŠ¤í˜ì´ìŠ¤ ì‚¬ìš©
```cpp
namespace rune_caster {
namespace language {

// êµ¬í˜„...

}  // namespace language
}  // namespace rune_caster
```

## ğŸ” ì˜ˆì œ ì°¸ì¡°

ì¢‹ì€ ìŠ¤íƒ€ì¼ì˜ ì˜ˆì œë“¤:
- [rune.hpp](mdc:include/rune_caster/rune.hpp) - í´ë˜ìŠ¤ ì„¤ê³„
- [rune.cpp](mdc:src/rune/rune.cpp) - êµ¬í˜„ íŒ¨í„´
- [basic_usage.cpp](mdc:examples/basic_usage.cpp) - ì‚¬ìš©ë²• ì˜ˆì œ
- [test_rune.cpp](mdc:tests/unit/test_rune.cpp) - í…ŒìŠ¤íŠ¸ ì‘ì„± ìŠ¤íƒ€ì¼
